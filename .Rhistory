tz_local = "Europe/Madrid",
time_column = "t",
value_column = "total_electricity",
temperature_column = "outdoor_temp",
GHI_column = "GHI",
intercept_column = "weekday",
windSpeed_column = "windSpeed",
group_column ="all",
hours_of_each_daypart = 4,
centroids = df_centroids,
centroids_summary = df_centroids_avg,
classification = classification[,c("date","s")]
)
source('~/Github/Bayes-M&V/preprocessing/clustering_beegeo.R')
characterization <- characterizer(
df_ini = df,
tz_local = "Europe/Madrid",
time_column = "t",
value_column = "total_electricity",
temperature_column = "outdoor_temp",
GHI_column = "GHI",
intercept_column = "weekday",
windSpeed_column = "windSpeed",
group_column ="all",
hours_of_each_daypart = 4,
centroids = df_centroids,
centroids_summary = df_centroids_avg,
classification = classification[,c("date","s")]
)
df_ini = df
tz_local = "Europe/Madrid"
time_column = "t"
value_column = "total_electricity"
temperature_column = "outdoor_temp"
GHI_column = "GHI"
intercept_column = "weekday"
windSpeed_column = "windSpeed"
group_column ="all"
hours_of_each_daypart = 4
centroids = df_centroids
centroids_summary = df_centroids_avg
classification = classification[,c("date","s")]
df_s <- aggregator(df_ini, value_column, temperature_column, windSpeed_column, GHI_column, time_column, intercept_column, tz_local,
group_column, hours_of_each_daypart)
df_s <- df_ini
if(class(df_s)=="data.frame"){ df_s <- list("all"=df_s)}
# Run the trainer of the model for a one-year-window rolling dataset by months
results_all <- lapply(names(df_s), function(gr){
#gr <- names(df_s)[1]
daily_df <- df_s[[gr]]
daily_df_roll_years <- rolling_dataset_by_n_months(df = daily_df, date_column = "day", n = 12)
results_year <- list()
features <- do.call(c,list(
lapply(1:(24/hours_of_each_daypart),FUN=function(x){list(min=12,max=25,n=15,class="float")}),
lapply(1:(24/hours_of_each_daypart),FUN=function(x){list(min=0,max=7,n=15,class="float")}),
lapply(1:length(levels(daily_df$s)),FUN=function(x){list(min=0,max=1,n=1,class="float")}),
list(list(min=1,max=100,n=31,class="float")),
list(list(min=0,max=1,n=1,class="int"))
))
names(features) <- c(
mapply(1:(24/hours_of_each_daypart),FUN=function(x){paste0("tbal_",x)}),
mapply(1:(24/hours_of_each_daypart),FUN=function(x){paste0("hysteresis_",x)}),
mapply(1:length(levels(daily_df$s)),FUN=function(x){paste0("seasonalities_wdep_",x)}),
"thermal_time_constant",
"training_without_holidays"
)
# tbal_min <- rep(10,(24/hours_of_each_daypart)) #*length(unique(daily_df$s))
# tbal_max <- rep(30,(24/hours_of_each_daypart))
# hysteresis_min <- rep(0,(24/hours_of_each_daypart))
# hysteresis_max <- rep(7,(24/hours_of_each_daypart))
# seasonalities_wdep_min <- rep(0,length(levels(daily_df$s)))
# seasonalities_wdep_max <- rep(1,length(levels(daily_df$s)))
y1 <- T
if(identical(daily_df_roll_years,list())){
return(NULL)
}
for (y in names(daily_df_roll_years)){
#y <- names(daily_df_roll_years)[1]#14
daily_df_year <- daily_df_roll_years[[y]]
rows_to_train <- do.call(c,lapply(unique(daily_df_year$s),
FUN= function(x){
sample(as.numeric(rownames(daily_df_year[daily_df_year$s==x,])),
nrow(daily_df_year[daily_df_year$s==x,])*1,replace = F)
}))
# Recursive Least Squares
# GA <- ga(type = "real-valued",
#          fitness = characterization_rls_model_trainer,
#          lower = c(tbal_min,hysteresis_min), upper = c(tbal_max,hysteresis_max),
#          df = daily_df_year,
#          temperature_column = temperature_column,
#          windSpeed_column = windSpeed_column,
#          GHI_column = GHI_column,
#          value_column = value_column,
#          intercept_column = intercept_column,
#          time_column = time_column,
#          daypart_column = "daypart",
#          for_optimize = T,
#          hours_of_each_daypart = hours_of_each_daypart,
#          rows_to_train = rows_to_train,
#          monitor=gaMonitor2,
#          maxiter=if(y1==T){100}else {10},popSize = 64,parallel= F,pmutation = 0.1)
# Least squares
# suggestions <- if(y1==T){
#   t(data.frame(
#     c(tbal_min,hysteresis_min,seasonalities_wdep_min),
#     c(tbal_max,hysteresis_max, seasonalities_wdep_max)))
# }else{
#   t(data.frame(
#     c(tbal,hysteresis,seasonalities_wdep),
#       c(tbal_min,hysteresis_min,seasonalities_wdep_min),
#       c(tbal_max,hysteresis_max,seasonalities_wdep_max))
#     )
# }
GA <- ga(#type = "real-valued",
type = "binary",
fitness = characterization_model_trainer,
# lower = c(tbal_min,hysteresis_min,seasonalities_wdep_min),
# upper = c(tbal_max,hysteresis_max,seasonalities_wdep_max),
nBits = sum(mapply(function(x) { nchar(toBin(x)) }, mapply(function(i){i[['n']]},features))),##MODEL
min_per_feature = mapply(function(i){i[['min']]},features),##DATA TO RUN
max_per_feature = mapply(function(i){i[['max']]},features),##DATA TO RUN
nclasses_per_feature = mapply(function(i){i[['n']]},features),##DATA TO RUN
class_per_feature = mapply(function(i){i[['class']]},features),##DATA TO RUN
names_per_feature = names(features),##DATA TO RUN
df = daily_df_year,
temperature_column = temperature_column,
windSpeed_column = windSpeed_column,
GHI_column = GHI_column,
value_column = value_column,
intercept_column = intercept_column,
time_column = time_column,
daypart_column = "daypart",
for_optimize = T,
hours_of_each_daypart = hours_of_each_daypart,
rows_to_train = NULL,#rows_to_train,
monitor = gaMonitor2,
suggestions = NULL,
selection = gabin_tourSelection,##MODEL
mutation = gabin_raMutation,
crossover = partial(bee_uCrossover,nclasses_per_feature = mapply(function(i){i[['n']]},features)),
optim = F,
maxiter=if(y1==T){30}else{12},popSize = 144,parallel= 24,pmutation = 0.05) #monitor = monitor)
params <- decodeValueFromBin(GA@solution[1,],
min_per_feature = mapply(function(i){i[['min']]},features),##DATA TO RUN
max_per_feature = mapply(function(i){i[['max']]},features),##DATA TO RUN
nclasses_per_feature = mapply(function(i){i[['n']]},features),##DATA TO RUN
class_per_feature = mapply(function(i){i[['class']]},features))##DATA TO RUN)
names(params) <- names(features)
tbal <- params[grepl("^tbal",names(params))]
hysteresis <- params[grepl("^hysteresis",names(params))]
seasonalities_wdep <- params[grepl("^seasonalities_wdep",names(params))]
thermal_time_constant <- params["thermal_time_constant"]
training_without_holidays <- params["training_without_holidays"]
for(tbal_item in names(features)[grepl("^tbal",names(features))]){
features[[tbal_item]]$min <- tbal[as.numeric(gsub("tbal_","",tbal_item))] - 2
features[[tbal_item]]$max <- tbal[as.numeric(gsub("tbal_","",tbal_item))] + 2
features[[tbal_item]]$n <- 3
}
for(hysteresis_item in names(features)[grepl("^hysteresis",names(features))]){
features[[hysteresis_item]]$min <-
if((hysteresis[as.numeric(gsub("hysteresis_","",hysteresis_item))]-0.5)>0){
hysteresis[as.numeric(gsub("hysteresis_","",hysteresis_item))] - 0.5
} else {0}
features[[hysteresis_item]]$max <-
if((hysteresis[as.numeric(gsub("hysteresis_","",hysteresis_item))]+0.5)<7){
hysteresis[as.numeric(gsub("hysteresis_","",hysteresis_item))] +0.5
} else {7}
features[[hysteresis_item]]$n <- 3
}
for(seasonalities_wdep_item in names(features)[grepl("^seasonalities_wdep",names(features))]){
features[[seasonalities_wdep_item]]$min <- seasonalities_wdep[as.numeric(gsub("seasonalities_wdep_","",seasonalities_wdep_item))]
if (seasonalities_wdep[as.numeric(gsub("seasonalities_wdep_","",seasonalities_wdep_item))] == 1){
features[[seasonalities_wdep_item]]$n <- 0
}
}
features[["thermal_time_constant"]]$min <- thermal_time_constant - 6
features[["thermal_time_constant"]]$max <- thermal_time_constant + 6
if(features[["thermal_time_constant"]]$min<1){
features[["thermal_time_constant"]]$min <- 1
}
if(features[["thermal_time_constant"]]$max>100){
features[["thermal_time_constant"]]$max <- 100
}
features[["thermal_time_constant"]]$n <- 7
daily_model <- characterization_model_trainer(
params = c(tbal,hysteresis,seasonalities_wdep,thermal_time_constant,training_without_holidays),
temperature_column = temperature_column,
windSpeed_column = windSpeed_column,
GHI_column = GHI_column,
value_column = value_column,
intercept_column = intercept_column,
time_column = time_column,
for_optimize = F,
daypart_column = "daypart",
df = daily_df_year,
hours_of_each_daypart = hours_of_each_daypart,
rows_to_train = NULL)
# daily_model <- characterization_rls_model_trainer(
#   params = c(tbal,hysteresis),
#   temperature_column = temperature_column,
#   windSpeed_column = windSpeed_column,
#   GHI_column = GHI_column,
#   value_column = value_column,
#   intercept_column = intercept_column,
#   time_column = time_column,
#   for_optimize = F,
#   daypart_column = "daypart",
#   df = daily_df_year,
#   hours_of_each_daypart = hours_of_each_daypart)
# coef(daily_model$mod)
# plotly::ggplotly(ggplot(daily_model$df)+geom_line(aes(time,powerContractM2))+geom_line(aes(time,pred),col="red",alpha=0.5))
# plotly::ggplotly(ggplot(daily_model$df)+geom_line(aes(time,powerContractM2))+geom_line(aes(time,pred_ini),col="red",alpha=0.5)+geom_line(aes(time,holidays_component),col="blue",alpha=0.5)+
#                    geom_point(aes(time,holidays_component,col=s),alpha=0.5))
# ggplot(daily_model$df) + geom_point(aes(time,powerContractM2,col=holidays))
daily_model$df[,group_column] <- daily_model$df$group
daily_model$df$rollYear <- y
#daily_model$summary[,group_column] <- gr
#daily_model$summary$rollYear <- y
results_year[[y]] <- list("df"=daily_model$df,
#"summary"=daily_model$summary,
"mod"=daily_model$mod)
y1 <- F
}
names(results_year) <- names(daily_df_roll_years)
gc(reset = T,full = T,verbose = F)
list(
"df"=do.call(rbind,lapply(results_year,function(i){i$df})),
#"summary"=do.call(rbind,lapply(results_year,function(i){i$summary})),
"mod"=lapply(results_year,function(i){i$mod})
)
})#, mc.cores= min(max(1,length(names(df_s))),detectCores()) )
if(class(df_s)=="data.frame"){ df_s <- list("all"=df_s)}
# Run the trainer of the model for a one-year-window rolling dataset by months
#gr <- names(df_s)[1]
daily_df <- df_s
daily_df_roll_years <- rolling_dataset_by_n_months(df = daily_df, date_column = "day", n = 12)
ts_min <- min(df[(month(df[,date_column]-days(1)) %% step)==1,date_column],na.rm=T)
date_column = "day"
n = 12
ts_min <- min(df[(month(df[,date_column]-days(1)) %% step)==1,date_column],na.rm=T)
df = daily_df
ts_min <- min(df[(month(df[,date_column]-days(1)) %% step)==1,date_column],na.rm=T)
df[,date_column]
df <- fread("data/Id50_hourly.csv",data.table = F)
head(df)
df <- df[,2:4]
colnames(df) <- c("t","total_electricity", "outdoor_temp")
df$t <- as.POSIXct(df$t,tz="Europe/Madrid")
df$t <- as.POSIXct(df$t, tz="Europe/Madrid")
df$local_date <- as.Date(df$t,tz="Europe/Madrid")
df <- merge(df,classification[,c("date","s")],by.x="local_date",by.y="date",all.x=T)
df$s<-as.factor(df$s)
df$all <- "all"
df$GHI <- 0
df$windSpeed <- 0
df_ini = df
df_s <- df_ini
# Run the trainer of the model for a one-year-window rolling dataset by months
#gr <- names(df_s)[1]
daily_df <- df_s
daily_df_roll_years <- rolling_dataset_by_n_months(df = daily_df, date_column = "day", n = 12)
df = daily_df
ts_min <- min(df[(month(df[,date_column]-days(1)) %% step)==1,date_column],na.rm=T)
daily_df_roll_years <- rolling_dataset_by_n_months(df = daily_df, date_column = "local_date", n = 12)
results_year <- list()
features <- do.call(c,list(
lapply(1:(24/hours_of_each_daypart),FUN=function(x){list(min=12,max=25,n=15,class="float")}),
lapply(1:(24/hours_of_each_daypart),FUN=function(x){list(min=0,max=7,n=15,class="float")}),
lapply(1:length(levels(daily_df$s)),FUN=function(x){list(min=0,max=1,n=1,class="float")}),
list(list(min=1,max=100,n=31,class="float")),
list(list(min=0,max=1,n=1,class="int"))
))
names(features) <- c(
mapply(1:(24/hours_of_each_daypart),FUN=function(x){paste0("tbal_",x)}),
mapply(1:(24/hours_of_each_daypart),FUN=function(x){paste0("hysteresis_",x)}),
mapply(1:length(levels(daily_df$s)),FUN=function(x){paste0("seasonalities_wdep_",x)}),
"thermal_time_constant",
"training_without_holidays"
)
y1 <- T
if(identical(daily_df_roll_years,list())){
return(NULL)
}
for (y in names(daily_df_roll_years)){
#y <- names(daily_df_roll_years)[1]#14
daily_df_year <- daily_df_roll_years[[y]]
rows_to_train <- do.call(c,lapply(unique(daily_df_year$s),
FUN= function(x){
sample(as.numeric(rownames(daily_df_year[daily_df_year$s==x,])),
nrow(daily_df_year[daily_df_year$s==x,])*1,replace = F)
}))
# Recursive Least Squares
# GA <- ga(type = "real-valued",
#          fitness = characterization_rls_model_trainer,
#          lower = c(tbal_min,hysteresis_min), upper = c(tbal_max,hysteresis_max),
#          df = daily_df_year,
#          temperature_column = temperature_column,
#          windSpeed_column = windSpeed_column,
#          GHI_column = GHI_column,
#          value_column = value_column,
#          intercept_column = intercept_column,
#          time_column = time_column,
#          daypart_column = "daypart",
#          for_optimize = T,
#          hours_of_each_daypart = hours_of_each_daypart,
#          rows_to_train = rows_to_train,
#          monitor=gaMonitor2,
#          maxiter=if(y1==T){100}else {10},popSize = 64,parallel= F,pmutation = 0.1)
# Least squares
# suggestions <- if(y1==T){
#   t(data.frame(
#     c(tbal_min,hysteresis_min,seasonalities_wdep_min),
#     c(tbal_max,hysteresis_max, seasonalities_wdep_max)))
# }else{
#   t(data.frame(
#     c(tbal,hysteresis,seasonalities_wdep),
#       c(tbal_min,hysteresis_min,seasonalities_wdep_min),
#       c(tbal_max,hysteresis_max,seasonalities_wdep_max))
#     )
# }
GA <- ga(#type = "real-valued",
type = "binary",
fitness = characterization_model_trainer,
# lower = c(tbal_min,hysteresis_min,seasonalities_wdep_min),
# upper = c(tbal_max,hysteresis_max,seasonalities_wdep_max),
nBits = sum(mapply(function(x) { nchar(toBin(x)) }, mapply(function(i){i[['n']]},features))),##MODEL
min_per_feature = mapply(function(i){i[['min']]},features),##DATA TO RUN
max_per_feature = mapply(function(i){i[['max']]},features),##DATA TO RUN
nclasses_per_feature = mapply(function(i){i[['n']]},features),##DATA TO RUN
class_per_feature = mapply(function(i){i[['class']]},features),##DATA TO RUN
names_per_feature = names(features),##DATA TO RUN
df = daily_df_year,
temperature_column = temperature_column,
windSpeed_column = windSpeed_column,
GHI_column = GHI_column,
value_column = value_column,
intercept_column = intercept_column,
time_column = time_column,
daypart_column = "daypart",
for_optimize = T,
hours_of_each_daypart = hours_of_each_daypart,
rows_to_train = NULL,#rows_to_train,
monitor = gaMonitor2,
suggestions = NULL,
selection = gabin_tourSelection,##MODEL
mutation = gabin_raMutation,
crossover = partial(bee_uCrossover,nclasses_per_feature = mapply(function(i){i[['n']]},features)),
optim = F,
maxiter=if(y1==T){30}else{12},popSize = 144,parallel= 24,pmutation = 0.05) #monitor = monitor)
params <- decodeValueFromBin(GA@solution[1,],
min_per_feature = mapply(function(i){i[['min']]},features),##DATA TO RUN
max_per_feature = mapply(function(i){i[['max']]},features),##DATA TO RUN
nclasses_per_feature = mapply(function(i){i[['n']]},features),##DATA TO RUN
class_per_feature = mapply(function(i){i[['class']]},features))##DATA TO RUN)
names(params) <- names(features)
tbal <- params[grepl("^tbal",names(params))]
hysteresis <- params[grepl("^hysteresis",names(params))]
seasonalities_wdep <- params[grepl("^seasonalities_wdep",names(params))]
thermal_time_constant <- params["thermal_time_constant"]
training_without_holidays <- params["training_without_holidays"]
for(tbal_item in names(features)[grepl("^tbal",names(features))]){
features[[tbal_item]]$min <- tbal[as.numeric(gsub("tbal_","",tbal_item))] - 2
features[[tbal_item]]$max <- tbal[as.numeric(gsub("tbal_","",tbal_item))] + 2
features[[tbal_item]]$n <- 3
}
for(hysteresis_item in names(features)[grepl("^hysteresis",names(features))]){
features[[hysteresis_item]]$min <-
if((hysteresis[as.numeric(gsub("hysteresis_","",hysteresis_item))]-0.5)>0){
hysteresis[as.numeric(gsub("hysteresis_","",hysteresis_item))] - 0.5
} else {0}
features[[hysteresis_item]]$max <-
if((hysteresis[as.numeric(gsub("hysteresis_","",hysteresis_item))]+0.5)<7){
hysteresis[as.numeric(gsub("hysteresis_","",hysteresis_item))] +0.5
} else {7}
features[[hysteresis_item]]$n <- 3
}
for(seasonalities_wdep_item in names(features)[grepl("^seasonalities_wdep",names(features))]){
features[[seasonalities_wdep_item]]$min <- seasonalities_wdep[as.numeric(gsub("seasonalities_wdep_","",seasonalities_wdep_item))]
if (seasonalities_wdep[as.numeric(gsub("seasonalities_wdep_","",seasonalities_wdep_item))] == 1){
features[[seasonalities_wdep_item]]$n <- 0
}
}
features[["thermal_time_constant"]]$min <- thermal_time_constant - 6
features[["thermal_time_constant"]]$max <- thermal_time_constant + 6
if(features[["thermal_time_constant"]]$min<1){
features[["thermal_time_constant"]]$min <- 1
}
if(features[["thermal_time_constant"]]$max>100){
features[["thermal_time_constant"]]$max <- 100
}
features[["thermal_time_constant"]]$n <- 7
daily_model <- characterization_model_trainer(
params = c(tbal,hysteresis,seasonalities_wdep,thermal_time_constant,training_without_holidays),
temperature_column = temperature_column,
windSpeed_column = windSpeed_column,
GHI_column = GHI_column,
value_column = value_column,
intercept_column = intercept_column,
time_column = time_column,
for_optimize = F,
daypart_column = "daypart",
df = daily_df_year,
hours_of_each_daypart = hours_of_each_daypart,
rows_to_train = NULL)
# daily_model <- characterization_rls_model_trainer(
#   params = c(tbal,hysteresis),
#   temperature_column = temperature_column,
#   windSpeed_column = windSpeed_column,
#   GHI_column = GHI_column,
#   value_column = value_column,
#   intercept_column = intercept_column,
#   time_column = time_column,
#   for_optimize = F,
#   daypart_column = "daypart",
#   df = daily_df_year,
#   hours_of_each_daypart = hours_of_each_daypart)
# coef(daily_model$mod)
# plotly::ggplotly(ggplot(daily_model$df)+geom_line(aes(time,powerContractM2))+geom_line(aes(time,pred),col="red",alpha=0.5))
# plotly::ggplotly(ggplot(daily_model$df)+geom_line(aes(time,powerContractM2))+geom_line(aes(time,pred_ini),col="red",alpha=0.5)+geom_line(aes(time,holidays_component),col="blue",alpha=0.5)+
#                    geom_point(aes(time,holidays_component,col=s),alpha=0.5))
# ggplot(daily_model$df) + geom_point(aes(time,powerContractM2,col=holidays))
daily_model$df[,group_column] <- daily_model$df$group
daily_model$df$rollYear <- y
#daily_model$summary[,group_column] <- gr
#daily_model$summary$rollYear <- y
results_year[[y]] <- list("df"=daily_model$df,
#"summary"=daily_model$summary,
"mod"=daily_model$mod)
y1 <- F
}
daily_df_roll_years
names(daily_df_roll_years)
y  = names(daily_df_roll_years)] < 1
y  = names(daily_df_roll_years)[1]
yù
y
#y <- names(daily_df_roll_years)[1]#14
daily_df_year <- daily_df_roll_years[[y]]
rows_to_train <- do.call(c,lapply(unique(daily_df_year$s),
FUN= function(x){
sample(as.numeric(rownames(daily_df_year[daily_df_year$s==x,])),
nrow(daily_df_year[daily_df_year$s==x,])*1,replace = F)
}))
rows_to_train
characterization_model_trainer
source('~/Github/Bayes-M&V/preprocessing/clustering_beegeo.R')
df_s <- df_ini
if(class(df_s)=="data.frame"){ df_s <- list("all"=df_s)}
# Run the trainer of the model for a one-year-window rolling dataset by months
#gr <- names(df_s)[1]
daily_df <- df_s
daily_df_roll_years <- rolling_dataset_by_n_months(df = daily_df, date_column = "local_date", n = 12)
results_year <- list()
features <- do.call(c,list(
lapply(1:(24/hours_of_each_daypart),FUN=function(x){list(min=12,max=25,n=15,class="float")}),
lapply(1:(24/hours_of_each_daypart),FUN=function(x){list(min=0,max=7,n=15,class="float")}),
lapply(1:length(levels(daily_df$s)),FUN=function(x){list(min=0,max=1,n=1,class="float")}),
list(list(min=1,max=100,n=31,class="float")),
list(list(min=0,max=1,n=1,class="int"))
))
names(features) <- c(
mapply(1:(24/hours_of_each_daypart),FUN=function(x){paste0("tbal_",x)}),
mapply(1:(24/hours_of_each_daypart),FUN=function(x){paste0("hysteresis_",x)}),
mapply(1:length(levels(daily_df$s)),FUN=function(x){paste0("seasonalities_wdep_",x)}),
"thermal_time_constant",
"training_without_holidays"
)
y1 <- T
if(identical(daily_df_roll_years,list())){
return(NULL)
}
y = names(daily_df_roll_years[1])
y = names(daily_df_roll_years)[1]
y
#y <- names(daily_df_roll_years)[1]#14
daily_df_year <- daily_df_roll_years[[y]]
daily_df_year
rows_to_train <- do.call(c,lapply(unique(daily_df_year$s),
FUN= function(x){
sample(as.numeric(rownames(daily_df_year[daily_df_year$s==x,])),
nrow(daily_df_year[daily_df_year$s==x,])*1,replace = F)
}))
rows_to_train
GA <- ga(#type = "real-valued",
type = "binary",
fitness = characterization_model_trainer,
# lower = c(tbal_min,hysteresis_min,seasonalities_wdep_min),
# upper = c(tbal_max,hysteresis_max,seasonalities_wdep_max),
nBits = sum(mapply(function(x) { nchar(toBin(x)) }, mapply(function(i){i[['n']]},features))),##MODEL
min_per_feature = mapply(function(i){i[['min']]},features),##DATA TO RUN
max_per_feature = mapply(function(i){i[['max']]},features),##DATA TO RUN
nclasses_per_feature = mapply(function(i){i[['n']]},features),##DATA TO RUN
class_per_feature = mapply(function(i){i[['class']]},features),##DATA TO RUN
names_per_feature = names(features),##DATA TO RUN
df = daily_df_year,
temperature_column = temperature_column,
windSpeed_column = windSpeed_column,
GHI_column = GHI_column,
value_column = value_column,
intercept_column = intercept_column,
time_column = time_column,
daypart_column = "daypart",
for_optimize = T,
hours_of_each_daypart = hours_of_each_daypart,
rows_to_train = NULL,#rows_to_train,
monitor = gaMonitor2,
suggestions = NULL,
selection = gabin_tourSelection,##MODEL
mutation = gabin_raMutation,
crossover = partial(bee_uCrossover,nclasses_per_feature = mapply(function(i){i[['n']]},features)),
optim = F,
maxiter=if(y1==T){30}else{12},popSize = 144,parallel= 24,pmutation = 0.05) #monitor = monitor)
